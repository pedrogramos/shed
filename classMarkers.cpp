#include <iostream>
#include <fstream>
#include <ostream>

using namespace std;

#include <stdio.h>
#include <cstdlib>
#include <math.h>
#include <getopt.h>

#include "oasystem.h"
#include "debuginfo.h"
#include <SDL.h>
#include <cv.h>
#include "highgui.h"

#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/calib3d/calib3d.hpp"


#include "oaengine.h"
#include "oasimpleobj.h"
#include "ar.h"
#include "gridloc.h"
#include "bploc.h"


#include <ros/ros.h>
#include <signal.h>
#include "geometry_msgs/Pose2D.h"
#include "RMPISR/resetrmp.h"

using namespace OpenAR;


GridLocator * startgridloc(ProjectiveCamera * cam){
  GridLocator* loc=new GridLocator();
  loc->setCameraModel(cam);
  return loc;
}



class markerDetection{

public:
	int detect();
	void ServiceCall(geometry_msgs::Pose2D);
	int errcb( int status, const char* func_name,  const char* err_msg, const char* file_name, int line, void* userdata );

private:
	ros::NodeHandle nh;
  	ros::ServiceClient client;
  	RMPISR::resetrmp srv;
  	geometry_msgs::Pose2D poseM;

  	//------------------------------//
	MarkerLocator * locator=NULL;
	bool capture_from_cam=false;
	unsigned long start, now;
	int viewangle=5;	
	int numM=0;	

	Pose pose,poseaux;	
	ProjectiveCamera cammodel;

	cv::Mat  iframe;
	cv::Mat  frame;
	cv::Mat  img;
	cv::Mat  img2;	
	bool doundistort=false;	

	oaEngine engine;
 	float ox,oy,oz;
  	CvFont font;
  	char msg[80];

	oaRenderer window;
  	cv::VideoCapture * capture;
	oaCamera * cam;
  	cam=new oaCamera;
	*capture >> iframe;





};


markerDetection::markerDetection(){
	cvRedirectError(errcb);
	client = nh.serviceClient<RMPISR::resetrmp>("resetrmp_");
	window.Init();
	window.CreateWindow(); 
	window.FinishSetup();
	window.setCamPose(0.0, 10.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, M_PI_2 );
	window.SetWindowTitle("MarkerLocator Demo");
  	cam->setIntrinsics(cammodel,iframe.cols,iframe.rows,1,50000);
  	cam->lookat(0,0,0,0,0,1,0,-1,0);
  
  	window.SetCamera(cam);

}

/*! function to be called in case of an error generated by OpenCV
 */
int markerDetection::errcb( int status, const char* func_name,  const char* err_msg, const char* file_name, int line, void* userdata ){
  cerr <<"Error on "<<func_name<<", msg= "<<err_msg<<" file "<< file_name<<" line"<< line<<endl;

  cerr<< "OpenCV Error: "<<cvErrorStr(status) <<endl;
  abort();
#ifdef _WIN32
  return 0;
#endif
}

void markerDetection::serciceCall(geometry_msgs::Pose2D pose1){
	srv.request.pose.x = pose1.x;
	srv.request.pose.y = pose1.y;
	srv.request.pose.x = pose1.theta;

	client.call(srv);

}



markerDetection::detect(){

	for(;;) {

		now = System::GetTicks();
			
		// capture one image
		*capture >> iframe ;

		if (doundistort){
		    cv::undistort(iframe,frame,cammodel.IntrinsicMatrix,cammodel.DistortionCoefficients);
		}
		else 
		    frame = iframe.clone();				

		if (locator){
		  numM=locator->DetectMarker(frame);
		  //numM=0;
		  locator->DrawMarkerFeatures(frame);
		  printf("MarkerTotal = %d\n",numM);

		  for(int lk=0;lk<numM;lk++){

				locator->useCVPose=true;
				pose=locator->getMarkerPose(lk);
				  
				pose.print();				


				//----------------------------------------
				  
				locator->useCVPose=false;
				pose=locator->getMarkerPose(lk);
				printf("From Homography\n");
				pose.print();
		
		
	

	  		}
		}
		cv::putText(frame,msg,cvPoint(10,50),cv::FONT_HERSHEY_SCRIPT_SIMPLEX,2, cv::Scalar::all(255),3,8);
		// set it as the opengl scene background

		engine.SetBGImage(frame);
		engine.renderScene(&window);




	}
}



int main(int argc, char** argv){

	// nome igual ao do ficheiro
	ros::init(argc, argv, "markerDetection_node");
	// criação do objecto da classe
	markerDetection marker;

	marker.detect();



}